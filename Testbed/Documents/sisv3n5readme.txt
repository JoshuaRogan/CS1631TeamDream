A Detailed Explanation of SIS System

Yao Sun
yaosun@cs.pitt.edu

1. Purpose of this readme
The purpose of this readme is to give SIS system developers a more deeper look into the current SIS system code(SIS Version 3.5). The readme will explain hopefully every detail of the SIS system. Topics span from SIS system message's data structure, the basic message routing of SISServer, general purpose component based system based upon SIS, and finally to sophisticated SIS system with Enumerator, Eliminator, DataSender, Verifier and TimeController.

2. Running Environment
Java 1.5 or later is required to run SIS system. For specific projects, see readme for the particular project.

3. Message structure of SIS system
3.1 Message Structure
SIS system is a component based software system. It uses one server multiple client model. Components within the SIS system communicate with each other using messages. The messages structures are explained below.
A message is a list of Key Value pairs. An example of the message is shown below
	MsgID		1000
	Description	Test message
	Name		Sender
	Key1		Value1
	Key2		Value2
2 fields are required for a message, MsgID and Description. MsgID should be an integer, it is used to identify a message in the SIS system. Description is just the description of this message. Usually Name field appears in a message, indicating the message sender component's name. Messages are case sensitive. Duplicated Keys are not allowed. The size of key value pairs are not restricted.
3.2 Message in the code
In the code, messages are stored in a class called KeyValueList. This class has the following useful methods
	size()				return how many key value pairs in the message
	keyAt(int i)			return the key in index i
	getValue(String key)		return value corresponding to key
	getValueLike(String keyword)	return values whose corresponding keys contains the input keyword as an ArrayList
	addPair(String k, String v)	add a key value pair
	setValue(String k, String v)	sets the value corresponding to the key
In SIS system, messages are sent using sockets. To send and receive message, 2 classes are provided, MsgEncoder and MsgDecoder.
MsgEncoder has a constructor MsgEncoder() and a method sendMsg(KeyValueList msg, OutputStream outstream)
MsgDecoder has a constructor MsgDecoder(InputStream instream) and a method KeyValueList getMsg()
In an SIS component, usually one MsgEncoder and one MsgDecoder is needed. They deal with all the incoming and outgoing messages using sendMsg(msg, socket.getOutputStream) and getMsg() methods respectively.
Besides MsgEncoder, another way to send a message is to directly send string through sockets. Messages are separated by newline characters. Within a message, $$$ is used to separate keys and values. For example, the string representation of the message in section 3.2 is
	MsgID$$$1000$$$Description$$$Test message$$$Name$$$Sender$$$Key1$$$Value1$$$Key2$$$Value2
3.3 Message Classification
All the messages in the SIS system has a MsgID field. MsgID is used to identify and classify a message. Below is the message classification.
	Messages with MsgID in 20-99 are system messages, these are closely related to the core of SISServer(the server of an SIS system)
	Messages with MsgID in 100-199 are used in Personal Health Care Project (Currently Deprecated)
	Messages with MsgID in 200-299 are used in Personal Health Care Project with Knowledge Base (Currently Deprecated)
	Messages with MsgID in 300-399 are used in Personal Health Care Project with Knowledge Base and under SIS framework(Currently Active)
	Messages with MsgID in 400-499 are used in Kinect project (Currently Active)
	Messages with MsgID in 500-599 are used in Social Influence Analysis Project (Currently Active)
	Messages with MsgID in 600-699 are used by projects generated by SISProjectCreator (Specific Purpose SIS system only)
	Messages with MsgID in 700-999 are reserved for future projects
	Messages with MsgID in 1000 and later are used in projects generated by SISProjectCreator (General Purpose Component Based System only)
SIS developers are advised to use messages with MsgID 1000 and later.
3.4 System Messages
As the previous section listed, messages with MsgID 20-99 are system messages. Below are the detailed description of these messages.
Messages 20 and 21 are used to register a component in an SIS system. The only difference is that message 21 registers a component which has a Knowledge Base, while message 20 registers a component which has no Knowledge Base. The message structure:
	MsgID		20|21
	Description	Create a certain component
	Name		Component Name to be created
	InputMsgID 1	the message the component could receive
	InputMsgID 2	the message the component could receive
	OutputMsgID 1	the message the component could send
	OutputMsgID 2	the message the component could send
	KnowledgeBase	the component's knowledge base (this field only appears in message 21)
Message 22 is the message from SISServer to a component, notifying the component is permanently discarded. The component usually exits after receiving this message. Message 24 is the message from SISServer to a component, notifying the component is temporarily deactivated. Message 25 is the message from SISServer to a component, notifying the component is reactivated. The message structure:
	MsgID		22|24|25
	Description	System Notification
	Name		SISServer
Message 23 is the message from a component to SISServer, declaring the component itself to SISServer. This message is used only in the component's first connection to SISServer to declare itself. If SISServer finds the component in its registry, SISServer will accept the connection and return a confirmation message 26. Then SISServer will accept forwarding messages from and to the component. Otherwise, the connection will be dropped directly. The message structure:
	MsgID		23|26
	Description	Connect to SISServer|Connection confirmation
	Name		The component name|SISServer
Message 27 is the message from a component to SISServer. It is used to check if a component is successfully connected to SISServer. SISServer will response using message 28. The message structure:
	MsgID		27|28
	Description	Check Connection|Check Connection Response
	Name		The Component sending Msg 27|SISServer
	CompName	The Component to be checked connection
	Connection	Value(Value should be "yes" or "no", this field only appears in message 28)

4. SISServer and prjRemote
4.1 What's SISServer and prjRemote
To constitute a minimal SIS system, SISServer and prjRemote are necessary. SISServer is the core part of an SIS system. It is the server of the system. All others including Eliminator, Enumerator, etc are clients in respect to SISServer. It deals and coordinates all the message communications within an SIS system. SISServer code is in 2 files. SISServer.java and SISComponentBase.java. The 2 files are under Testbed/System/SISServer or Testbed/SISServer. 
PrjRemote is the SIS system administrator tool to initialize and monitor an SIS system. It can be seen as a visual component of SISServer. PrjRemote can also be used by SIS system administrator to send test messages, register a component with SISServer, enable or disable components, etc by sending corresponding system messages decribed in section 3.4. SIS system administrator could monitor all the message routing in prjRemote and do interruptions if needed.
4.2 Start the SISServer
To start an SIS system, first starts SISServer either using runServer under Testbed/Scripts or just go to SISServer directory
	javac *.java
	java SISServer
Then open the prjRemote.jar, click Connect button. The address and port is set default as 127.0.0.1:7999. Now SISServer is up and running.
4.3 SISServer's behavior
SISServer will check and forward all the messages between components and all the messages between SISServer and components. This means all the messages are through SISServer. Components' communications are monitored by SISServer. If one component is to send a message to another, it sends the message to SISServer, after SISServer checks the message, it forwards the message to receiving components.
How does SISServer know which component should send which message, or which component should receive which message. It's done through searching its registry. After comparing the message and the component with the registry, SISServer could do the routing. The registry is empty at SISServer's start, it's built from messages 20 and messages 21. SIS system administrator could send messages 20 and 21 through prjRemote to initialize SISServer.

5. General Component Based System
SIS system can be used as a general component based system. In this system, all the components are treated equal. The system structure could be simple, one server and multiple components. In general component based system, messages are usually used to send and receive data. So messages in this system are always with MsgID 1000 and later. As a result, components in general component based system cannot create, enable or disable other components. All the components are parts of the system to do one job. SISProjectCreator could be used to create general component based systems. It can generate scripts and template codes of components specified in the system.

6. Specific SIS System
6.1 SIS System's Job
The main purpose of the specific SIS system is to run and test multiple algorithms with multiple parameters. After some rounds of run and test, the system could pick algorithms with better performance and discard algorithms with worse performance, it could also pick parameters for selected algorithms. Algorithms are classified into different groups called Cycles. Algorithms within one Cycle do the same job on the same input data. One algorithm could be instantiated multiple instances with different parameters. The goal of specific SIS system is to pick algorithms with proper parameters for each Cycle to fit the problem, or environment.
6.2 SIS System Components
A specific SIS system typically includes the following 5 components called system components. They are Enumerator, DataSender, Verifier, Eliminator and TimeController. The functions of the system components are as below.
	Enumerator enumerates algorithms with different parameters on Cycle basis. Algorithms could be instantiated sequentially or in parallel.
	DataSender sends test input data to algorithm instances created by Enumerator.
	Verifier evaluates algorithm instances' outputs and send evaluation to Eliminator.
	Eliminator eliminates algorithm instances by their performances on Cycle basis.
	TimeController determines which Cycle(s) to start upon current Cycle(s) running complete. 
A Cycle running complete means Enumerator instantiates all the algorithms with all possible parameters and Eliminator eliminates and concentrates algorithm instances to only one algorithm instance with specific parameters in the Cycle. 
Therefore, specific SIS system runs on Cycle basis.
6.3 System detailed process
Below is a brief description of the messages routing within specific SIS system.
When the 5 system components started. TimeController first sends a message to Enumerator to notify which Cycle(s) to start, then Enumerator will start instantiating algorithms and sends messages to Eliminator about algorithm instances. When enumeration round completes, Enumerator sends another messageto notify Eliminator enumeration round complete. Enumerator then sends a message to DataSender to ask DataSender to send data message. DataSender sends data message, algorithm instances proces the data and send result message. Verifier processes result message and sends Eliminator result evaluation. Then Eliminator checks if all the algorithm instances have returned results, if yes, Eliminator sends message to ask DataSender to send data message. DataSender may continue to send data message or if all the data are sent, DataSender sends a message to tell Eliminator data exhausted. Then Eliminator do the elimination and sends the result to Enumerator. If Enumerator has more algorithms to instantiate, it starts next round of enumeration and after all the above steps Eliminator eliminates this round of algorithm instances. If Enumerator has no more algorithms to instantiate, Enumerator do the final elimination, leaving only one algorithm instance for each cycle and notify the TimeController Cycle running complete. TimeController checks is all the active Cycles running complete, if yes, TimeController resets the system and notify Enumerator to start running on next Cycle(s). If TimeController has no more Cycles to run, the SIS system running complete.
Different specific SIS system might go through a slightly different process, SISProjectCreator could generate a quite sophisticated specific SIS system template, including customization on system behavior.

7. Steps to Run an SIS System
7.1 SISProjectCreator Generated General Component Based System
For General Component Based System created using SISProjectCreator, follow the steps below to start the system.
-- run SISServer following instructions in section 4.2
-- run prjRemote, the SISServer address is 127.0.0.1 if SISServer is running on local machine, port number is always 7999, and then click Connect button
-- in prjRemote, load init xmls from ProjectFolder/xml/InitXML/list_InitXML.txt and then click Send All button, if list_InitXML.txt cannot be loaded, open the file and check if the paths are correct, or manually load all the xmls under ProjectFolder/xml/InitXML directory
-- run the runAllComps.bat under ProjectFolder/Scripts to start all the components at once or start components individually using scripts under ProjectFolder/Scripts/runIndividualComp. If using operating system other than Windows, open the runAllComps.bat and type the javac and java commands in the scripts under command line terminal to manually start all the components under ProjectFolder/Components
7.2 SISProjectCreator Generated Specific Purpose SIS System
For Specific Purpose SIS System created using SISProjectCreator, follow the steps below to start the system.
-- run SISServer following instructions in section 4.2
-- run prjRemote, the SISServer address is 127.0.0.1 if SISServer is running on local machine, port number is always 7999, and then click Connect button
-- in prjRemote, load init xmls from ProjectFolder/xml/InitXML/list_InitXML.txt and then click Send All button, if list_InitXML.txt cannot be loaded, open the file and check if the paths are correct, or manually load all the xmls under ProjectFolder/xml/InitXML directory, mainly CreateEnumerator.XML, CreateEliminator.XML, CreateDataSender.XML, CreateVerifier.XML, CreateTimeController.XML
-- run the 5 scripts under ProjectFolder/Scripts, they are runEnumerator.bat, runEliminator.bat, runDataSender.bat, runVerifier.bat and runTimeController.bat. Note runTimeController.bat should be started after all other 4 scripts are started. If using operating system other than Windows, open the 5 scripts and type the javac and java commands in the scripts under command line terminal to manually start all the system components under ProjectFolder/System, they are Enumerator, Eliminator, DataSender, Verifier and TimeController.
7.3 SIS System from Scratch
If the system is written without the help from SISProjectCreator, the whole system should be started manually, basic steps are as below.
-- run SISServer following instructions in section 4.2
-- run prjRemote, the SISServer address is 127.0.0.1 if SISServer is running on local machine, port number is always 7999, and then click Connect button
-- in prjRemote, load init xmls and send them to SISServer
-- manually start components
Detailed information could be found in Testbed/System/SISServer/SISsetup






